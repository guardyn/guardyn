/// MLS Key Package Management Handlers
///
/// Handles upload and retrieval of MLS key packages for group chat encryption.
/// Key packages are pre-generated by clients and stored on the server.
/// When a user is added to a group, their key package is fetched and used
/// to generate a Welcome message.

use crate::db::DatabaseClient;
use crate::jwt::verify_jwt;
use crate::proto::auth::{
    GetMlsKeyPackageRequest, GetMlsKeyPackageResponse, GetMlsKeyPackageSuccess,
    UploadMlsKeyPackageRequest, UploadMlsKeyPackageResponse, UploadMlsKeyPackageSuccess,
};
use crate::proto::common::{ErrorResponse, Timestamp};
use sha2::{Digest, Sha256};
use std::collections::HashMap;
use std::sync::Arc;
use std::time::SystemTime;
use tonic::{Request, Response, Status};
use tracing::{error, info};

/// Upload MLS key package for group chat
///
/// Stores the serialized MLS KeyPackage in TiKV.
/// Each user/device can have multiple key packages (for key rotation).
///
/// # Storage Schema
/// - `/mls/key_packages/<user_id>/<device_id>/<package_id>` → key_package_bytes
/// - `/mls/key_packages/by_user/<user_id>` → list of package_ids
pub async fn upload_mls_key_package(
    request: Request<UploadMlsKeyPackageRequest>,
    db: Arc<DatabaseClient>,
) -> Result<Response<UploadMlsKeyPackageResponse>, Status> {
    let req = request.into_inner();
    info!("Uploading MLS key package");

    // Validate JWT token
    let user_id = match verify_jwt(&req.access_token, "your-secret-key") { // TODO: Get from config
        Ok(user_id) => user_id,
        Err(e) => {
            error!("JWT validation failed: {:?}", e);
            return Ok(Response::new(UploadMlsKeyPackageResponse {
                result: Some(crate::proto::auth::upload_mls_key_package_response::Result::Error(
                    ErrorResponse {
                        code: crate::proto::common::error_response::ErrorCode::Unauthorized as i32,
                        message: format!("Invalid token: {}", e),
                        details: HashMap::new(),
                    },
                )),
            }));
        }
    };

    let device_id = "default"; // TODO: Extract from token claims or request

    // Validate key package
    if req.key_package.is_empty() {
        return Ok(Response::new(UploadMlsKeyPackageResponse {
            result: Some(crate::proto::auth::upload_mls_key_package_response::Result::Error(
                ErrorResponse {
                    code: crate::proto::common::error_response::ErrorCode::InvalidRequest as i32,
                    message: "Key package cannot be empty".to_string(),
                    details: HashMap::new(),
                },
            )),
        }));
    }

    // Generate package ID (hash of key package for uniqueness)
    let mut hasher = Sha256::new();
    hasher.update(&req.key_package);
    let package_id = hex::encode(hasher.finalize());

    // Store key package in TiKV
    let key = format!("/mls/key_packages/{}/{}/{}", user_id, device_id, package_id);
    match db.put(key.as_bytes(), req.key_package).await {
        Ok(_) => {
            info!("MLS key package uploaded: {} for user {}", package_id, user_id);

            // Add to user's package list (for rotation/cleanup)
            let list_key = format!("/mls/key_packages/by_user/{}/{}", user_id, device_id);
            let _ = db.put(list_key.as_bytes(), package_id.as_bytes().to_vec()).await;

            let now = SystemTime::now()
                .duration_since(SystemTime::UNIX_EPOCH)
                .unwrap()
                .as_secs();

            Ok(Response::new(UploadMlsKeyPackageResponse {
                result: Some(crate::proto::auth::upload_mls_key_package_response::Result::Success(
                    UploadMlsKeyPackageSuccess {
                        package_id,
                        uploaded_at: Some(Timestamp {
                            seconds: now as i64,
                            nanos: 0,
                        }),
                    },
                )),
            }))
        }
        Err(e) => {
            error!("Failed to store MLS key package: {:?}", e);
            Ok(Response::new(UploadMlsKeyPackageResponse {
                result: Some(crate::proto::auth::upload_mls_key_package_response::Result::Error(
                    ErrorResponse {
                        code: crate::proto::common::error_response::ErrorCode::InternalError as i32,
                        message: "Failed to store key package".to_string(),
                        details: { let mut map = HashMap::new(); map.insert("error".to_string(), e.to_string()); map },
                    },
                )),
            }))
        }
    }
}

/// Get MLS key package for a user
///
/// Fetches a key package for adding a user to a group.
/// If device_id is specified, fetches for that device.
/// Otherwise, fetches for any available device.
///
/// # Returns
/// - Key package bytes (serialized MLS KeyPackage)
/// - Package ID (for tracking which package was used)
pub async fn get_mls_key_package(
    request: Request<GetMlsKeyPackageRequest>,
    db: Arc<DatabaseClient>,
) -> Result<Response<GetMlsKeyPackageResponse>, Status> {
    let req = request.into_inner();
    info!("Getting MLS key package for user: {}", req.user_id);

    // Validate input
    if req.user_id.is_empty() {
        return Ok(Response::new(GetMlsKeyPackageResponse {
            result: Some(crate::proto::auth::get_mls_key_package_response::Result::Error(
                ErrorResponse {
                    code: crate::proto::common::error_response::ErrorCode::InvalidRequest as i32,
                    message: "User ID cannot be empty".to_string(),
                    details: HashMap::new(),
                },
            )),
        }));
    }

    // Determine device_id
    let device_id = if req.device_id.is_empty() {
        // Fetch any available device's key package
        // TODO: Implement device discovery logic
        // For now, return error if device_id not specified
        return Ok(Response::new(GetMlsKeyPackageResponse {
            result: Some(crate::proto::auth::get_mls_key_package_response::Result::Error(
                ErrorResponse {
                    code: crate::proto::common::error_response::ErrorCode::InvalidRequest as i32,
                    message: "Device ID must be specified".to_string(),
                    details: HashMap::new(),
                },
            )),
        }));
    } else {
        req.device_id.clone()
    };

    // Get package list for user/device
    let list_key = format!("/mls/key_packages/by_user/{}/{}", req.user_id, device_id);
    match db.get(list_key.as_bytes()).await {
        Ok(Some(package_id_bytes)) => {
            let package_id = String::from_utf8_lossy(&package_id_bytes).to_string();

            // Fetch the key package
            let key = format!("/mls/key_packages/{}/{}/{}", req.user_id, device_id, package_id);
            match db.get(key.as_bytes()).await {
                Ok(Some(key_package)) => {
                    info!("MLS key package found: {} for user {}", package_id, req.user_id);
                    Ok(Response::new(GetMlsKeyPackageResponse {
                        result: Some(crate::proto::auth::get_mls_key_package_response::Result::Success(
                            GetMlsKeyPackageSuccess {
                                user_id: req.user_id,
                                device_id,
                                key_package,
                                package_id,
                            },
                        )),
                    }))
                }
                Ok(None) => {
                    error!("MLS key package not found: {} for user {}", package_id, req.user_id);
                    Ok(Response::new(GetMlsKeyPackageResponse {
                        result: Some(crate::proto::auth::get_mls_key_package_response::Result::Error(
                            ErrorResponse {
                                code: crate::proto::common::error_response::ErrorCode::NotFound as i32,
                                message: "Key package not found".to_string(),
                                details: HashMap::new(),
                            },
                        )),
                    }))
                }
                Err(e) => {
                    error!("Failed to fetch MLS key package: {:?}", e);
                    Ok(Response::new(GetMlsKeyPackageResponse {
                        result: Some(crate::proto::auth::get_mls_key_package_response::Result::Error(
                            ErrorResponse {
                                code: crate::proto::common::error_response::ErrorCode::InternalError as i32,
                                message: "Failed to fetch key package".to_string(),
                                details: { let mut map = HashMap::new(); map.insert("error".to_string(), e.to_string()); map },
                            },
                        )),
                    }))
                }
            }
        }
        Ok(None) => {
            error!("No MLS key packages found for user: {}", req.user_id);
            Ok(Response::new(GetMlsKeyPackageResponse {
                result: Some(crate::proto::auth::get_mls_key_package_response::Result::Error(
                    ErrorResponse {
                        code: crate::proto::common::error_response::ErrorCode::NotFound as i32,
                        message: "No key packages available for user".to_string(),
                        details: HashMap::new(),
                    },
                )),
            }))
        }
        Err(e) => {
            error!("Failed to query MLS key packages: {:?}", e);
            Ok(Response::new(GetMlsKeyPackageResponse {
                result: Some(crate::proto::auth::get_mls_key_package_response::Result::Error(
                    ErrorResponse {
                        code: crate::proto::common::error_response::ErrorCode::InternalError as i32,
                        message: "Failed to query key packages".to_string(),
                        details: { let mut map = HashMap::new(); map.insert("error".to_string(), e.to_string()); map },
                    },
                )),
            }))
        }
    }
}
